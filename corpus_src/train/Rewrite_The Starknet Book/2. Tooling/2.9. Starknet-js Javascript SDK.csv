question,answer
What is Starknet.js?,"Starknet.js is a JavaScript/TypeScript library designed to connect your website or decentralized application (D-App) to Starknet. It aims to mimic the architecture of ethers.js, so if you are familiar with ethers, you should find Starknet.js easy to work with."
How to use Starknet.js?,"First, you need to install Starknet.js, follow these steps:

For the latest official release (main branch):
npm install starknet
To use the latest features (merges in develop branch):
npm install starknet@next

Then, you can Get start with Starknet.js.

To build an app that users are able to connect to and interact with Starknet, we recommend adding the get-starknet library, which allows you to manage wallet connections. With these tools ready, there are basically 4 main concepts to know on the frontend: Account, Provider,  Contracts and Units.

1. Account

We can generally think of the account as the ¡®end user¡¯ of a dapp, and some user interaction will be involved to gain access to it.

Think of a dapp where the user connects their browser extension wallet (such as ArgentX or Braavos) - if the user accepts the connection, that gives us access to the account and signer, which can sign transactions and messages.

Unlike Ethereum, where user accounts are Externally Owned Accounts, Starknet accounts are contracts. This might not necessarily impact your dapp¡¯s frontend, but you should definitely be aware of this difference.
///
async function connectWallet() {
    const starknet = await connect();
    console.log(starknet.account);

    const nonce = await starknet.account.getNonce();
    const message = await starknet.account.signMessage(...)
}
///
The snippet above uses the ¡®connect¡¯ function provided by ¡®get-starknet¡¯ to establish a connection to the user wallet. Once connected, we are able to access account methods, such as ¡®signMessage¡¯ or ¡®execute¡¯.

2. Provider

The provider allows you to interact with the Starknet network. You can think of it as a ¡®read¡¯ connection to the blockchain, as it doesn¡¯t allow signing transactions or messages. Just like in Ethereum, you can use a default provider, or use services such as Infura or Alchemy, both of which support Starknet, to create an RPC provider. By default, the Provider is a sequencer provider.
///
export const provider = new Provider({
  sequencer: {
    network: ¡®goerli-alpha¡¯,
  },
  // rpc: {
  //   nodeUrl: INFURA_ENDPOINT
  // }
});

const block = await provider.getBlock(¡®latest¡¯); // <- Get latest block
console.log(block.block_number);
///

3. Contracts

Your frontend will likely be interacting with deployed contracts. For each contract, there should be a counterpart on the frontend. To create these instances, you will need the contract¡¯s address and ABI, and either a provider or signer.
///
const contract = new Contract(abi_erc20, contractAddress, starknet.account);

const balance = await contract.balanceOf(starknet.account.address);
const transfer = await contract.transfer(recipientAddress, amountFormatted);
//or: const transfer = await contract.invoke(¡®transfer¡¯, [to, amountFormatted]);

console.log(`Tx hash: ${transfer.transaction_hash}`);
///
If you create a contract instance with a provider, you¡¯ll be limited to calling read functions on the contract - only with a signer can you change the state of the blockchain. However, you are able to connect a previously created ¡®Contract¡¯ instance with a new account:
///
const contract = new Contract(abi_erc20, contractAddress, provider);

contract.connect(starknet.account);
///
In the snippet above, after calling the ¡®connect¡¯ method, it would be possible to call read functions on the contract, but not before.

4. Units

If you have previous experience with web3, you know dealing with units requires care, and Starknet is no exception. Very often you will need to convert Cairo structs (such as Uint256) that are returned from contracts into numbers:
///
// Uint256 shape:
// {
//    type: 'struct',
//    low: Uint256.low,
//    high: Uint256.high
//
// }
const balance = await contract.balanceOf(address); // <- uint256
const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN
const asString = asBN.toString(); //<- BN into string
///

And vice versa:
///
const amount = 1;

const amountFormatted = {
  type: ¡®struct¡¯,
  ...uint256.bnToUint256(amount),
};
///
There are other helpful utils, besides ¡®bnToUint256¡¯ and ¡®uint256ToBN¡¯, provided by Starknet.js.

We now have a solid foundation to build a Starknet dapp. However, there are framework specific tools that help us build Starknet dapps, which are covered in chapter 5.

With Starknet.js, you can also automate the process of deploying a smart contract to Starknet testnet / mainnet."
How to deploy smart contractusing Starknet.js?,"Starknet.js offers capabilities for deploying smart contracts. In this tutorial, we demonstrate this by deploying an account contract, which we previously developed in Chapter 4, through a scripted approach.

STEP 1: Initial Setup and Dependency Installation

To begin, set up your project environment for the account contract deployment. Within your project'sroot directory, start by initializing a Node.js environment:

npm init -y

This command generates a package.json file. Next, update this file to include the latest versions of the necessary dependencies:
///
¡®@tsconfig/node20¡¯: ¡®^20.1.2¡¯,
¡®axios¡¯: ¡®^1.6.0¡¯,
¡®chalk¡¯: ¡®^5.3.0¡¯,
¡®dotenv¡¯: ¡®^16.3.1¡¯,
¡®starknet¡¯: ¡®^5.19.5¡¯,
¡®ts-node¡¯: ¡®^10.9.1¡¯,
¡®typescript¡¯: ¡®^5.2.2¡¯
///
With the dependencies specified, install them using:

npm install

Configuration of TypeScript Environment

Create a ¡®tsconfig.json¡¯ file in your project directory:
///
{
  ¡®extends¡¯: ¡®./node_modules/@tsconfig/node20/tsconfig.json¡¯,
  ¡®include¡¯: [¡®scripts/**/*¡¯]
}
///
Ensure your Node.js version aligns with v20 to match this configuration.

Furthermore, establish a ¡®.env¡¯ file at the root of your project. This file should contain your RPC endpoint and the private key of your deployer account:
///
DEPLOYER_PRIVATE_KEY=<YOUR_WALLET_ADDRESS_PRIVATE_KEY>
RPC_ENDPOINT=¡®<INFURA_STARKNET_GOERLI_API_KEY>¡®
///
Your environment is successfully set up.

Then, to facilitate the deployment of the account contract, three key files are necessary:

¡®utils.ts¡¯: This file will contain the functions and logic for deployment.
¡®deploy.ts¡¯: This is the main deployment script.
¡®l2-eth-abi.json¡¯: his file will hold the ABI (Application Binary Interface) for the account contract.

STEP 2: Import Required Modules and Functions

In the ¡®utils.ts¡¯ file, import the necessary modules and functions from various packages. This includes functionality from Starknet, filesystem operations, path handling, and environment variable configuration:
///
import {
  Account,
  stark,
  ec,
  hash,
  CallData,
  RpcProvider,
  Contract,
  cairo,
} from ¡®starknet¡¯;
import { promises as fs } from ¡®fs¡¯;
import path from ¡®path¡¯;
import readline from ¡®readline¡¯;
import ¡®dotenv/config¡¯;
///

STEP 3: Implementing the waitForEnter Function

To enhance user interaction during the deployment process, implement the ¡®waitForEnter¡¯ function. This function prompts the user to press 'Enter' to proceed, ensuring an interactive session:
///
export async function waitForEnter(message: string): Promise<void> {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    rl.question(message, (_) => {
      rl.close();
      resolve();
    });
  });
}
///

STEP 4: Styling Terminal Output Messages

Integrate the ¡®chalk¡¯ module for styling terminal output messages. This enhances the readability and user experience in the command line interface:
///
export async function importChalk() {
  return import(¡®chalk¡¯).then((m) => m.default);
}
///

STEP 5: Establishing Connection to the Starknet Network

Configure the ¡®RpcProvider¡¯ object to connect to the Starknet network. This connection uses the RPC endpoint specified in the ¡®.env¡¯ file, facilitating communication through the Infura client:
///
export function connectToStarknet() {
  return new RpcProvider({
    nodeUrl: process.env.RPC_ENDPOINT as string,
  });
}
///

STEP 6: Preparing the Deployer Account

Set up the deployer account for contract deployment. Utilize the private key from the ¡®.env¡¯ file and its respective pre-deployed address to create a new ¡®Account¡¯ object:
///
export function getDeployerWallet(provider: RpcProvider) {
  const privateKey = process.env.DEPLOYER_PRIVATE_KEY as string;
  const address =
    ¡®0x070a0122733c00716cb9f4ab5a77b8bcfc04b707756bbc27dc90973844a752d1¡¯;
  return new Account(provider, address, privateKey);
}
///

STEP 7: Generating a Key Pair for the Account Contract

The next step involves generating a key pair for the account contract using the ¡®stark¡¯ object from Starknet.js. The key pair consists of a private key and a corresponding public key:
///
export function createKeyPair() {
  const privateKey = stark.randomAddress();
  const publicKey = ec.starkCurve.getStarkKey(privateKey);
  return {
    privateKey,
    publicKey,
  };
}
///

Note: If a specific private key is required, replace stark.randomAddress() with the desired private key.

STEP 8: Importing Compiled Account Contract Files

After compiling the account contract with ¡®scarb build¡¯, Sierra and Casm files are generated in the ¡®target/dev/¡¯directory:

Sierra File: <Project_File_Name>.contract_class.json
Casm File: <Project_File_Name>.compiled_contract_class.json

To import these files into the deployment script, specify their absolute paths:
///
export async function getCompiledCode(filename: string) {
  const sierraFilePath = path.join(
    __dirname,
    `../target/dev/${filename}.contract_class.json`,
  );
  const casmFilePath = path.join(
    __dirname,
    `../target/dev/${filename}.compiled_contract_class.json`,
  );

  const code = [sierraFilePath, casmFilePath].map(async (filePath) => {
    const file = await fs.readFile(filePath);
    return JSON.parse(file.toString(¡®ascii¡¯));
  });

  const [sierraCode, casmCode] = await Promise.all(code);

  return {
    sierraCode,
    casmCode,
  };
}
///
We use ¡®fs¡¯ method to read the file contents.

STEP 9: Declaration of the Account Contract
To declare the account contract's class, define an ¡®interface¡¯ containing all necessary fields for the declaration, then use the ¡®declare()¡¯ method:
///
interface DeclareAccountConfig {
  provider: RpcProvider;
  deployer: Account;
  sierraCode: any;
  casmCode: any;
}

export async function declareContract({
  provider,
  deployer,
  sierraCode,
  casmCode,
}: DeclareAccountConfig) {
  const declare = await deployer.declare({
    contract: sierraCode,
    casm: casmCode,
  });
  await provider.waitForTransaction(declare.transaction_hash);
}
///

STEP 10: Deploying the Account Contract

To deploy the account contract, calculate its address using the contract's class hash. After determining the address, fund it using the Starknet Faucet to cover gas fees during deployment:
///
interface DeployAccountConfig {
  privateKey: string;
  publicKey: string;
  classHash: string;
  provider: RpcProvider;
}

export async function deployAccount({
  privateKey,
  publicKey,
  classHash,
  provider,
}: DeployAccountConfig) {
  const chalk = await importChalk();

  const constructorArgs = CallData.compile({
    public_key: publicKey,
  });

  const myAccountAddress = hash.calculateContractAddressFromHash(
    publicKey,
    classHash,
    constructorArgs,
    0,
  );

  console.log(`Send ETH to contract address ${chalk.bold(myAccountAddress)}`);
  const message = ¡®Press [Enter] when ready...¡¯;
  await waitForEnter(message);

  const account = new Account(provider, myAccountAddress, privateKey, ¡®1¡¯);

  const deploy = await account.deployAccount({
    classHash: classHash,
    constructorCalldata: constructorArgs,
    addressSalt: publicKey,
  });

  await provider.waitForTransaction(deploy.transaction_hash);
  return deploy.contract_address;
}
///

STEP 11: Interacting with the Deployed Account Contract

Once the account contract is successfully deployed, we can test it by sending test Ethereum (ETH) to another address:
///
interface TransferEthConfig {
  provider: RpcProvider;
  account: Account;
}

export async function transferEth({ provider, account }: TransferEthConfig) {
  const L2EthAddress =
    ¡®0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7¡¯;

  const L2EthAbiPath = path.join(__dirname, ¡®./l2-eth-abi.json¡¯);
  const L2EthAbiFile = await fs.readFile(L2EthAbiPath);
  const L2ETHAbi = JSON.parse(L2EthAbiFile.toString(¡®ascii¡¯));

  const contract = new Contract(L2ETHAbi, L2EthAddress, provider);

  contract.connect(account);

  const recipient =
    ¡®0x05feeb3a0611b8f1f602db065d36c0f70bb01032fc1f218bf9614f96c8f546a9¡¯;
  const amountInGwei = cairo.uint256(100);

  await contract.transfer(recipient, amountInGwei);
}

export async function isContractAlreadyDeclared(
  classHash: string,
  provider: RpcProvider,
) {
  try {
    await provider.getClassByHash(classHash);
    return true;
  } catch (error) {
    return false;
  }
}
///
With the necessary functions in place, we can now write the deployment script in ¡®deploy.ts¡¯, which orchestrates the deployment and verification process:
///
import { hash, LibraryError, Account } from ¡®starknet¡¯;

import {
  importChalk,
  connectToStarknet,
  getDeployerWallet,
  createKeyPair,
  getCompiledCode,
  declareContract,
  deployAccount,
  transferEth,
  isContractAlreadyDeclared,
} from ¡®./utils¡¯;

async function main() {
  const chalk = await importChalk();
  const provider = connectToStarknet();
  const deployer = getDeployerWallet(provider);
  const { privateKey, publicKey } = createKeyPair();

  console.log(chalk.yellow(¡®Account Contract:¡¯));
  console.log(`Private Key = ${privateKey}`);
  console.log(`Public Key = ${publicKey}`);

  let sierraCode, casmCode;
  try {
    ({ sierraCode, casmCode } = await getCompiledCode(¡®aa_Account¡¯));
  } catch (error: any) {
    console.log(chalk.red(¡®Failed to read contract files¡¯));
    process.exit(1);
  }

  const classHash = hash.computeContractClassHash(sierraCode);
  const isAlreadyDeclared = await isContractAlreadyDeclared(
    classHash,
    provider,
  );

  if (isAlreadyDeclared) {
    console.log(chalk.yellow(¡®Contract class already declared¡¯));
  } else {
    try {
      console.log(¡®Declaring account contract...¡¯);
      await declareContract({ provider, deployer, sierraCode, casmCode });
      console.log(chalk.green(¡®Account contract successfully declared¡¯));
    } catch (error: any) {
      console.log(chalk.red(¡®Declare transaction failed¡¯));
      console.log(error);
      process.exit(1);
    }
  }

  console.log(`Class Hash = ${classHash}`);

  let address: string;
  try {
    console.log(¡®Deploying account contract...¡¯);
    address = await deployAccount({
      privateKey,
      publicKey,
      classHash,
      provider,
    });
    console.log(
      chalk.green(`Account contract successfully deployed to Starknet testnet`),
    );
  } catch (error: any) {
    if (
      error instanceof LibraryError &&
      error.message.includes(¡®balance is smaller¡¯)
    ) {
      console.log(chalk.red(¡®Insufficient account balance for deployment¡¯));
      process.exit(1);
    } else {
      console.log(chalk.red(¡®Deploy account transaction failed¡¯));
      process.exit(1);
    }
  }

  const account = new Account(provider, address, privateKey, ¡®1¡¯);

  try {
    console.log(¡®Testing account by transferring ETH...¡¯);
    await transferEth({ provider, account });
    console.log(chalk.green(`Account works!`));
  } catch (error) {
    console.log(chalk.red(¡®Failed to transfer ETH¡¯));
    process.exit(1);
  }
}

main();
///
The ¡®main¡¯ function orchestrates the entire deployment process, from creating a key pair to declaring and deploying the account contract, and finally testing its functionality by executing a transfer transaction.
"
Can you give me an example contract using Starknet.js?,"Here is a simple counter smart contract with a frontend. By the end of this guide, you will understand how to:

1.Connect the frontend to a smart contract.
2.Initiate transactions, such as incrementing or decrementing the counter.
3.Read and display data, such as showing the counter value on the frontend.

For a visual walkthrough, do check out the Basecamp frontend session. This comprehensive session delves deeper into the nuances of the concepts we've touched upon, presenting a mix of theoretical explanations and hands-on demonstrations.

1.Tools Used

1.Reactjs: A frontend building framework.
2.@argent/get-starknet: A wrapper for starknet.js, aiding interaction with wallet extensions.
3.starknet: A JavaScript library for Starknet.

2.Setting Up the Environment

To begin, clone the project repository:

git clone https://github.com/Darlington02/basecamp-frontend-boilerplate

Then, navigate to the project directory and install necessary packages:

cd basecamp-frontend-boilerplate
npm install

To launch the project, run:

yarn start

In ¡®index.js¡¯, several key functions are provided:

// Connect to the blockchain via a wallet provider (argentX or Bravoos)
const connectWallet = async () => {};

// Terminate the connection
const disconnectWallet = async () => {};

// Trigger increment
const increaseCounter = async () => {};

// Trigger decrement
const decreaseCounter = async () => {};

// Retrieve current count
const getCounter = async () => {};

3.Managing Connection

The ¡®connectWallet¡¯ function serves as the mechanism to establish a connection to the blockchain through specific wallet providers such as ArgentX or Braavos. It is asynchronous, allowing the use of ¡®await¡¯ for handling asynchronous tasks.
///
const connectWallet = async() => {
    const connection = await connect({webWalletUrl: ""https://web.argent.xyz""});
    if (connection && connection.isConnected) {
      setConnection(connection);
      setAccount(connection.account);
      setAddress(connection.selectedAddress);
    }
}
///
Initiates the connection using the ¡®connect¡¯ method from the ¡®@argent/get-starknet¡¯ library, targeting Starknet.
Upon a successful connection, updates the React component's state with details of the ¡®connection¡¯, ¡®account¡¯, and ¡®selectedAddress¡¯.

The ¡®disconnectWallet¡¯ function is designed to sever the connection with the web wallet asynchronously. After disconnection, it updates the component's state, resetting connection details.
///
const disconnectWallet = async() => {
    await disconnect();
    setConnection(undefined);
    setAccount(undefined);
    setAddress('');
}
///
It utilizes the ¡®disconnect¡¯ function, possibly from an external library, and handles the operation asynchronously with ¡®await¡¯.
Post-disconnection, the state of the React component is updated:

¡®setConnection¡¯ is set to undefined.
¡®setAccount¡¯ is set to undefined.
¡®setAddress¡¯ is cleared with an empty string.

The ¡®EagerlyConnect¡¯ mechanism leverages React's ¡®useEffect¡¯ hook to initiate a connection to Starknet upon the component's mounting or initial rendering.
///
useEffect(() => {
  const connectToStarknet = async () => {
    const connection = await connect({
      modalMode: ""neverAsk"",
      webWalletUrl: ""https://web.argent.xyz"",
    });

    if (connection && connection.isConnected) {
      setConnection(connection);
      setAccount(connection.account);
      setAddress(connection.selectedAddress);
    }
  };
  connectToStarknet();
}, []);
///
Inside the ¡®useEffect¡¯, the ¡®connectToStarknet¡¯ function is defined, aiming to establish an asynchronous connection using the ¡®connect¡¯ function. Parameters like ¡®modalMode¡¯ and ¡®webWalletUrl¡¯ are passed to guide the connection process.

If successful in connecting (¡®connection && connection.isConnected¡¯), the state updates with details of the connection, the account, and the selected address using ¡®setConnection¡¯, ¡®setAccount¡¯, and ¡®setAddress¡¯.

The ¡®connectToStarknet¡¯ function is executed immediately after its definition.

4.Important Refresher on Smart Contract Interactions

For effective interaction with a smart contract on the network, it's crucial to understand key components after establishing a connection. Among these are the ¡®contract address¡¯, ¡®ABI¡¯, ¡®Signer¡¯, and ¡®Provider¡¯.

1.ABI (Application Binary Interface) is a standardized bridge between two binary program modules. It is essential for:

Interacting with smart contracts on the blockchain.
Specifying the structure of functions, events, and variables for software applications.
Enabling smooth communication with the smart contract, detailing function signatures, input/output types, event formats, and variable types.

Facilitating invocation of functions and data retrieval from the contract.

2.Signer

The Signer plays a pivotal role in:

Signing transactions.
Authorizing actions on the blockchain.
Bearing the fees associated with blockchain operations.

Signers are especially linked to write operations that change the state of the blockchain. These operations need cryptographic signing for security and validity.

3.Provider

The Provider acts as the medium for:

Communication with the blockchain.
Creating transactions.
Fetching data from the blockchain.

To initiate a write transaction, the connected account (signer) must be provided. This signer then signs the transaction, bearing the necessary fee for execution.

5.Invoking the increment Function
///
const increaseCounter = async () => {
  try {
    const contract = new Contract(contractAbi, contractAddress, account);
    await contract.increment();
    alert(""You successfully incremented the counter!"");
  } catch (err) {
    alert(err.message);
  }
};
///
The ¡®increaseCounter¡¯ function is crafted to interact with a smart contract and increment a specific counter. Here's a step-by-step breakdown:

1.Establishes a new contract instance using the provided contract's ABI, its address, and the connected account. The account is essential since this write transaction alters the contract's state.
2.Executes the contract's ¡®increment¡¯ method. The ¡®await¡¯ keyword ensures the program pauses until this action completes.
3.On successful execution, the user receives a confirmation alert indicating the counter's increment.
4.In case of any errors during the process, an alert displays the corresponding error message to the user.

6.Invoking the decrement Function
///
const decreaseCounter = async () => {
  try {
    const contract = new Contract(contractAbi, contractAddress, account);
    await contract.decrement();
    alert(""You successfully decremented the counter!"");
  } catch (err) {
    alert(err.message);
  }
};
///
The ¡®decreaseCounter¡¯ function is designed to interact with a smart contract and decrement a specific counter. Here's a succinct breakdown of its operation:

1.Creates a new contract instance by utilizing the provided contract's ABI, its address, and the connected account. The account is vital as this write transaction modifies the contract's state.
2.Initiates the contract's ¡®decrement¡¯ method. With the use of the ¡®await¡¯ keyword, the program ensures it waits for the decrement action to finalize.
3.Upon successful execution, the user is notified with an alert indicating the counter's decrement.
4.Should any errors arise during the interaction, the user is promptly alerted with the pertinent error message.

7.Fetching the Current Count with get_current_count Function
///
const getCounter = async () => {
  const provider = new Provider({
    sequencer: { network: constants.NetworkName.SN_MAIN },
  });
  try {
    const mycontract = new Contract(contractAbi, contractAddress, provider);
    const num = await mycontract.get_current_count();
    setRetrievedValue(num.toString());
  } catch (err) {
    alert(err.message);
  }
};
///
The ¡®getCounter¡¯ function is designed to retrieve the current count from a smart contract. Here's a breakdown of its operation:

1.Establishes a provider instance, specifying the sequencer network ¨C in this instance, it's set to the ¡®mainnet¡¯ through ¡®constants.NetworkName.SN_MAIN¡¯.
2.With this provider, it then initiates a contract instance using the provided contract's ABI, its address, and the aforementioned provider.
3.The function then invokes the ¡®get_current_count¡¯ method of the contract to fetch the current count. This is an asynchronous action, and the program waits for its completion with the ¡®await¡¯ keyword.
4.Once successfully retrieved, the count, which is presumably a number, is converted to a string and stored using the ¡®setRetrievedValue¡¯ function.
5.In the event of any errors during the process, an alert provides the user with the relevant error message.

It's essential to emphasize that while performing read operations, like fetching data from a blockchain network, the function uses the provider. Unlike write operations, which typically require a signer (or an account) for transaction signing, read operations don't mandate such authentication. Thus, in this function, only the provider is specified, and not the signer."
Can you give me another example contract using Starknet.js?,"Here is an example ERC20 smart contract using Cairo and to incorporate it within a React web application with StarknetJS. You will:

1.Understand how to implement the ERC20 interface
2.Learn how to deploy contracts on the Starknet network
3.Discover ways to engage with contracts within a React application
4.Design their own ERC20 token and initiate it on Starknet

A prerequisite for this guide is a foundational understanding of both the Cairo programming language and StarknetJS. Additionally, ensure Node.js and NPM are installed on the system.

The example will walk through creating an ERC20 token named MKT and crafting a web3 interface for functionalities such as balance verification and token transfer.

1.Throughout this guide, the following tools and libraries will be utilized:

Scarb 0.7.0 with Cairo 2.2.0
Starkli 0.1.9
Oppenzeppelin libraries v0.7.0
StarknetJS v5.19.5
get-starknet v3.0.1
NodeJS v19.6.1
Next.js 13.5.5
Visual Studio Code
Vercel

2.Initiating a New Starknet Project

Begin by establishing a new Starknet project named ¡®erc20¡¯ using Scarb:

mkdir erc20
cd erc20
scarb init --name erc20

Subsequently, update the Scarb.toml to include the essential OpenZeppelin libraries. Post edits, the Scarb.toml should appear as:
///
[package]
name = ¡®erc20¡¯
version = ¡®0.1.0¡¯

# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = ¡®>=2.2.0¡¯
openzeppelin = { git = ¡®https://github.com/OpenZeppelin/cairo-contracts.git¡¯, tag = ¡®v0.7.0¡¯ }

[[target.starknet-contract]]
///

3.Implementing the ERC20 Token

Begin by creating a new file named ¡®src/erc20.cairo¡¯. In this file, the ERC20 token named MKT, along with its associated functions, will be defined:

#[starknet::contract]
mod erc20 {
    use starknet::ContractAddress;
    use openzeppelin::token::erc20::ERC20;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = 'MyToken';
        let symbol = 'MTK';

        let mut unsafe_state = ERC20::unsafe_new_contract_state();
        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);
        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);
    }

    #[external(v0)]
    #[generate_trait]
    impl Ierc20Impl of Ierc20 {
        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {
            let unsafe_state = ERC20::unsafe_new_contract_state();
            ERC20::ERC20Impl::balance_of(@unsafe_state, account)
        }

        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {
            let mut unsafe_state = ERC20::unsafe_new_contract_state();
            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)
        }
    }
}

Now edit src/lib.cairo and replace the content with:

mod erc20;

Upon completing your contract, proceed to compile it using Scarb:

scarb build

Subsequent to the compilation, declare the smart contract on the Starknet testnet (using your own account and keystore):

starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 ¨Cwatch

The output should appear similar to:

Enter keystore password:
Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713
... [shortened for brevity]
Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713

In cases where no modifications have been made to the provided contract, a notification will indicate that the contract has previously been declared on Starknet:

Enter keystore password:
Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713

4.Deploying the ERC20 Contract

Proceed to deploy the MKT Token using Starkli. Provide these arguments for successful deployment:

1.¡¯Initial mint¡¯: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 * 10^18 or 0xd3c21bcecceda1000000. Due to the contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.
2.¡¯Receiver address¡¯: Use a preferred address who wiil be the initial recipient of 1,000,000 MKT. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc

starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc

The output should appear similar to:

Enter keystore password:
... [shortened for brevity]
Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f

NOTE: The deployed address received will differ for every user. Retain this address, as it will replace instances in subsequent TypeScript files to match the specific contract address.

Well done! The Cairo ERC20 smart contract has been deployed successfully on Starknet.

5.Setting Up a New React Project

With the contract in place, initiate the development of the web application. Begin by setting up our react project. To do this, Nextjs framework provides the ¡®create-next-app¡¯ script that streamlines the setup of a Nextjs application:

npx create-next-app@latest erc20_web --use-npm
? Would you like to use TypeScript? ¡­ Yes
? Would you like to use ESLint? ¡­ Yes
? Would you like to use Tailwind CSS? ¡­ Yes
? Would you like to use `src/` directory? ¡­ Yes
? Would you like to use App Router? (recommended) ¡­ Yes
? Would you like to customize the default import alias (@/*)? ¡­ No

Then, you should see something like this:

Creating a new Next.js app in /home/kali/cairo/erc20_web.
Using npm.
Initializing project with template: app-tw
Installing dependencies:
- react
- react-dom
- next

... [shortened for brevity]

Initialized a git repository.
Success! Created erc20_web at /home/kali/cairo/erc20_web

6.Installing the Starknet.js Library

Now, let's install the starknet.js and recommended get-starknet (manage wallet connections) libraries:

cd erc20_web
npm install get-starknet

You should see something like this:

added 3 packages, changed 1 package, and audited 1549 packages in 7s
... [shortened for brevity]
Run `npm audit` for details.

Install starknetJS:

npm install starknet

You should see something like this:

added 18 packages, and audited 1546 packages in 6s
... [shortened for brevity]
Run `npm audit` for details.

Post-installation, confirm the version of the Starknet.js library:

npm list starknet

npm list get-starknet

The output should display the installed version, such as ¡®starknet@5.19.5¡¯ and get-¡®starknet@3.0.1¡¯.

7.Building our Project

Once set up, make modifications to ¡®erc20_web/src/app/layout.tsx¡¯ by replacing its content with the following code:
///
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang=¡®en¡¯>
      <body>{children}</body>
    </html>
  )
}
///
Now, edit ¡®erc20_web/src/app/page.tsx¡¯ and replace its content with the following code:
///
import Head from ¡®next/head¡¯;
import App from ¡®../components/App¡¯;

export default function Home() {

  return (
    <>
      <Head>
        <title>Homepage</title>
        <link rel=¡®icon¡¯ href=¡®/favicon.ico¡¯ />
      </Head>
      <main>
      <p>A basic web3 example with StarknetJS</p>
          <App />
      </main>
    </>
  );
}
///

8.Enhancing Your React Application with Additional Features

To enhance the app's functionality, create one component (erc20_web/src/components/App.tsx) for balance and transfer with the following code.
///
'use client';
import { useState, useMemo } from ¡®react¡¯
import { connect, disconnect } from ¡®get-starknet¡¯
import { Contract, Provider, SequencerProvider, constants } from ¡®starknet¡¯

const contractAddress = ¡®0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f¡¯

function App() {
  const [provider, setProvider] = useState({} as Provider)
  const [address, setAddress] = useState('')
  const [currentBlockHash, setCurrentBlockHash] = useState('')
  const [balance, setBalance] = useState('')
  const [isConnected, setIsConnected] = useState(false)
  const [recipient, setRecipient] = useState('0x');
  const [amount, setAmount] = useState('1000000000000000000');

  const disconnectWallet = async () => {
    try {
      await disconnect({ clearLastWallet: true })
      setProvider({} as Provider)
      setAddress('')
      setIsConnected(false)
    }
    catch (error: any) {
      alert(error.message)
    }
  }

  const connectWallet = async () => {
    try {
      const starknet = await connect()
      if (!starknet) throw new Error(¡®Failed to connect to wallet.¡¯)
      await starknet.enable({ starknetVersion: ¡®v5¡¯ })
      setProvider(starknet.account)
      setAddress(starknet.selectedAddress || '')
      setIsConnected(true)
    }
    catch (error: any) {
      alert(error.message)
    }
  }

  const checkBalance = async () => {
    try {
      // initialize contract using abi, address and provider
      const { abi: testAbi } = await provider.getClassAt(contractAddress);
      if (testAbi === undefined) { throw new Error(¡®no abi.¡¯) };
      const contract = new Contract(testAbi, contractAddress, provider)
      // make contract call
      const data = await contract.balance_of(address)
      setBalance(data.toString())
    }
    catch (error: any) {
      alert(error.message)
    }
  }

  const transfer = async () => {
    try {
      // initialize contract using abi, address and provider
      const { abi: testAbi } = await provider.getClassAt(contractAddress);
      if (testAbi === undefined) { throw new Error(¡®no abi.¡¯) };
      const contract = new Contract(testAbi, contractAddress, provider)
      // make contract call
      await contract.transfer(recipient, amount)
    }
    catch (error: any) {
      alert(error.message)
    }
  }

  const current_block_hash = async () => {
    try {
      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });

      const block = await provider1.getBlock(¡®latest¡¯); // <- Get latest block
      setCurrentBlockHash(block.block_hash);
    }
    catch (error: any) {
      alert(error.message)
    }
  }

  current_block_hash()

  const shortenedAddress = useMemo(() => {
    if (!isConnected) return ''
    return `${address.slice(0, 6)}...${address.slice(-4)}`
  }, [isConnected, address])

  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRecipient(event.target.value);
  };

  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {
      setAmount(event.target.value);
  };

  return (
    <div>
      <p>Latest block hash: {currentBlockHash}</p>
      {isConnected ?
        <div>
          <span>Connected: {shortenedAddress}</span>
          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>
          <hr />
          <p>Balance.</p>
          <p>{balance}</p>
          <p><button onClick={() => checkBalance()}>Check Balance</button></p>
          <hr />
          <p>Transfer.</p>
          <p>Recipient:
              <input
              type=¡®text¡¯
              value={recipient}
              onChange={handleRecipientChange}
              />
          </p>
          <p>Amount (default 1 MKT with 18 decimals):
            <input
            type=¡®number¡¯
            value={amount}
            onChange={handleAmountChange}
            />
          </p>
          <p>
            <button onClick={() => transfer()}>Transfer</button>
          </p>
          <hr/>
        </div> :
        <div>
          <span>Choose a wallet:</span>
          <p>
            <button onClick={() => connectWallet()}>Connect a Wallet</button>
          </p>
        </div>
      }
    </div>
  );
}

export default App;
///
Finally, launch the web3 application:

cd erc20_web/
npm run dev

Congratulations, you have your starknetjs web3 application. Now connect your wallet in goerli testnet, check your balance and transfer MKT tokens to your friends:

9.Deploying Your Project Online

To share your application with friends and allow them to check their balances and transfer tokens, publish your app online. Vercel offers a straightforward way to do this:

Set Up Vercel
1.Register for an account at Vercel Signup.
2.Install Vercel in your web application folder (erc20_web):

cd erc20_web/
npm i -g vercel

3.Authenticate your Vercel account:

vercel login
Continue with Email (or select your preferred login method)

After entering your email, check your inbox and click on the ¡®Verify¡¯ button.

On successful verification, you'll receive a confirmation in the console.

4.Link your project to Vercel:

vercel link
? Set up ¡®~/cairo/erc20_web¡¯? [Y/n] y
? Which scope should contain your project? (just press enter)
? Link to existing project? [y/N] n
? What¡¯s your project¡¯s name? erc20-web
? In which directory is your code located? ./
? Want to modify these settings? [y/N] n
Linked erc20-web (created .vercel)

5.Upload it:

vercel

6.Publish your project:

vercel --prod
Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]

Check your production URL and congratulations! Your MKT token web3 application is now accessible to everyone.

Engage with your app by:

1.Connecting your wallet.
2.Checking your balance.
3.Transferring tokens.
"
